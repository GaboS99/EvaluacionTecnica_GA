{"version":"15.1.4","vulnerabilities":[{"id":"59840d4da5e8f9fbccd7e7736129501f83252734adbff745cf6d334f5032e79a","category":"sast","name":"Detect manually constructed URLs","description":"User data flows into the host portion of this manually-constructed URL.\nThis could allow an attacker to send data to their own server, potentially\nexposing sensitive data such as cookies or authorization information sent\nwith this request. They could also probe internal servers or other\nresources that the server running this code can access. (This is called\nserver-side request forgery, or SSRF.) Do not allow arbitrary hosts.\nInstead, create an allowlist for approved hosts hardcode the correct host,\nor ensure that the user data can only affect the path or parameters.\n\nExample of using allowlist:\n```\nArrayList\u003cString\u003e allowlist = (ArrayList\u003cString\u003e)\n    Arrays.asList(new String[] { \"https://example.com/api/1\", \"https://example.com/api/2\", \"https://example.com/api/3\"});\n\nif(allowlist.contains(url)){\n  ...\n}\n```\n","cve":"semgrep_id:java_endpoint_rule-ManuallyConstructedURLs:57:57","severity":"Critical","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderJKUEndpoint.java","start_line":57},"identifiers":[{"type":"semgrep_id","name":"java_endpoint_rule-ManuallyConstructedURLs","value":"java_endpoint_rule-ManuallyConstructedURLs"},{"type":"cwe","name":"CWE-918","value":"918","url":"https://cwe.mitre.org/data/definitions/918.html"},{"type":"owasp","name":"A10:2021 - Server-Side Request Forgery","value":"A10:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"}]},{"id":"f1516942018c41375633be0c1609e3cdf635c56c9cfe581366a242a12f96d651","category":"sast","name":"Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')","description":"Detected a potential path traversal. A malicious actor could control\nthe location of this file, to include going backwards in the directory\nwith '../'. \n\nTo address this, ensure that user-controlled variables in file\npaths are sanitized. You may also consider using a utility method such as\norg.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file\nname from the path.\n\nExample code using FilenameUtils.getName(...)\n\n```\npublic void ok(HttpServletRequest request, HttpServletResponse response)\n        throws ServletException, IOException {\n    String image = request.getParameter(\"image\");\n    File file = new File(\"static/images/\", FilenameUtils.getName(image));\n\n    if (!file.exists()) {\n        log.info(image + \" could not be created.\");\n        response.sendError();\n    }\n\n    response.sendRedirect(\"/index.html\");\n}\n```\n","cve":"semgrep_id:java_file_rule-FilePathTraversalHttpServlet:100:101","severity":"Critical","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","start_line":100,"end_line":101},"identifiers":[{"type":"semgrep_id","name":"java_file_rule-FilePathTraversalHttpServlet","value":"java_file_rule-FilePathTraversalHttpServlet","url":"https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN"},{"type":"cwe","name":"CWE-22","value":"22","url":"https://cwe.mitre.org/data/definitions/22.html"},{"type":"owasp","name":"A01:2021 - Broken Access Control","value":"A01:2021"},{"type":"owasp","name":"A5:2017 - Broken Access Control","value":"A5:2017"}]},{"id":"0a00111307956696f71c0211a23b76483a9a3885ce6c89f97810ec71d1ac99ca","category":"sast","name":"Relative Path Traversal","description":"Detected user input controlling a file path. An attacker could control\nthe location of this file, to include going backwards in the directory\nwith '../'. \n\nTo address this, ensure that user-controlled variables in file\npaths are sanitized. You may also consider using a utility method such as\norg.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file\nname from the path.\n\nExample of using `org.apache.commons.io.FilenameUtils.getName(...)` to \nonly retrieve the file name from the path\n```\nString fileName = org.apache.commons.io.FilenameUtils.getName(userControlledInput);\nFile file = new File(\"/path/to/directory/\" + fileName);\n```\n","cve":"semgrep_id:java_traversal_rule-RelativePathTraversal:79:79","severity":"Critical","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","start_line":79},"identifiers":[{"type":"semgrep_id","name":"java_traversal_rule-RelativePathTraversal","value":"java_traversal_rule-RelativePathTraversal"},{"type":"cwe","name":"CWE-23","value":"23","url":"https://cwe.mitre.org/data/definitions/23.html"},{"type":"owasp","name":"A01:2021 - Broken Access Control","value":"A01:2021"},{"type":"owasp","name":"A5:2017 - Broken Access Control","value":"A5:2017"}]},{"id":"50da8e5dac11e8d68608748e4cf84d051eec5924704a927982656a56724960b5","category":"sast","name":"Improper neutralization of special elements used in an SQL command ('SQL Injection')","description":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user-supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `\u003e` or `\u003c` comparison\noperators. In these cases, do not use a user supplied `\u003e` or `\u003c` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `\u003e` and `\u003c`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nExample on using CriteriaBuilder to build queries\n```\npublic List\u003cYourEntity\u003e findBySomeCriteria(EntityManager entityManager, String criteriaValue) {\n    CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();\n    CriteriaQuery\u003cYourEntity\u003e query = criteriaBuilder.createQuery(YourEntity.class);\n    Root\u003cYourEntity\u003e root = query.from(YourEntity.class);\n\n    query.select(root).where(criteriaBuilder.equal(root.get(\"someProperty\"), criteriaValue));\n\n    return entityManager.createQuery(query).getResultList();\n}\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n","cve":"semgrep_id:java_inject_rule-SqlInjection:142:142","severity":"High","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","start_line":142},"identifiers":[{"type":"semgrep_id","name":"java_inject_rule-SqlInjection","value":"java_inject_rule-SqlInjection"},{"type":"cwe","name":"CWE-89","value":"89","url":"https://cwe.mitre.org/data/definitions/89.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"}]},{"id":"9ecd71b459f8e2523a6dc4d978b9d479c0b64f0cae40e1e1283af5269c29fe11","category":"sast","name":"Improper neutralization of special elements used in an SQL command ('SQL Injection')","description":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user-supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `\u003e` or `\u003c` comparison\noperators. In these cases, do not use a user supplied `\u003e` or `\u003c` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `\u003e` and `\u003c`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nExample on using CriteriaBuilder to build queries\n```\npublic List\u003cYourEntity\u003e findBySomeCriteria(EntityManager entityManager, String criteriaValue) {\n    CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();\n    CriteriaQuery\u003cYourEntity\u003e query = criteriaBuilder.createQuery(YourEntity.class);\n    Root\u003cYourEntity\u003e root = query.from(YourEntity.class);\n\n    query.select(root).where(criteriaBuilder.equal(root.get(\"someProperty\"), criteriaValue));\n\n    return entityManager.createQuery(query).getResultList();\n}\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n","cve":"semgrep_id:java_inject_rule-SqlInjection:46:46","severity":"High","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java","start_line":46},"identifiers":[{"type":"semgrep_id","name":"java_inject_rule-SqlInjection","value":"java_inject_rule-SqlInjection"},{"type":"cwe","name":"CWE-89","value":"89","url":"https://cwe.mitre.org/data/definitions/89.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"}]},{"id":"2866bc80a188d1d1c4d4269a63a4e276db482e4624172eece36c897edd8c07aa","category":"sast","name":"Improper neutralization of special elements used in an SQL command ('SQL Injection')","description":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user-supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `\u003e` or `\u003c` comparison\noperators. In these cases, do not use a user supplied `\u003e` or `\u003c` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `\u003e` and `\u003c`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nExample on using CriteriaBuilder to build queries\n```\npublic List\u003cYourEntity\u003e findBySomeCriteria(EntityManager entityManager, String criteriaValue) {\n    CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();\n    CriteriaQuery\u003cYourEntity\u003e query = criteriaBuilder.createQuery(YourEntity.class);\n    Root\u003cYourEntity\u003e root = query.from(YourEntity.class);\n\n    query.select(root).where(criteriaBuilder.equal(root.get(\"someProperty\"), criteriaValue));\n\n    return entityManager.createQuery(query).getResultList();\n}\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n","cve":"semgrep_id:java_inject_rule-SqlInjection:47:47","severity":"High","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java","start_line":47},"identifiers":[{"type":"semgrep_id","name":"java_inject_rule-SqlInjection","value":"java_inject_rule-SqlInjection"},{"type":"cwe","name":"CWE-89","value":"89","url":"https://cwe.mitre.org/data/definitions/89.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"}]},{"id":"4dcfd06da4b0ec7e584b21b920c3953bf2ccf2ecd3e981aaaa3ad0ff53341709","category":"sast","name":"Improper neutralization of special elements used in an SQL command ('SQL Injection')","description":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user-supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `\u003e` or `\u003c` comparison\noperators. In these cases, do not use a user supplied `\u003e` or `\u003c` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `\u003e` and `\u003c`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nExample on using CriteriaBuilder to build queries\n```\npublic List\u003cYourEntity\u003e findBySomeCriteria(EntityManager entityManager, String criteriaValue) {\n    CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();\n    CriteriaQuery\u003cYourEntity\u003e query = criteriaBuilder.createQuery(YourEntity.class);\n    Root\u003cYourEntity\u003e root = query.from(YourEntity.class);\n\n    query.select(root).where(criteriaBuilder.equal(root.get(\"someProperty\"), criteriaValue));\n\n    return entityManager.createQuery(query).getResultList();\n}\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n","cve":"semgrep_id:java_inject_rule-SqlInjection:49:49","severity":"High","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson2.java","start_line":49},"identifiers":[{"type":"semgrep_id","name":"java_inject_rule-SqlInjection","value":"java_inject_rule-SqlInjection"},{"type":"cwe","name":"CWE-89","value":"89","url":"https://cwe.mitre.org/data/definitions/89.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"}]},{"id":"98ee46066622ad89690b1d7038e6df42b862e81f785cd89fa40324e83ffc9913","category":"sast","name":"Improper neutralization of special elements used in an SQL command ('SQL Injection')","description":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user-supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `\u003e` or `\u003c` comparison\noperators. In these cases, do not use a user supplied `\u003e` or `\u003c` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `\u003e` and `\u003c`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nExample on using CriteriaBuilder to build queries\n```\npublic List\u003cYourEntity\u003e findBySomeCriteria(EntityManager entityManager, String criteriaValue) {\n    CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();\n    CriteriaQuery\u003cYourEntity\u003e query = criteriaBuilder.createQuery(YourEntity.class);\n    Root\u003cYourEntity\u003e root = query.from(YourEntity.class);\n\n    query.select(root).where(criteriaBuilder.equal(root.get(\"someProperty\"), criteriaValue));\n\n    return entityManager.createQuery(query).getResultList();\n}\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n","cve":"semgrep_id:java_inject_rule-SqlInjection:49:49","severity":"High","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java","start_line":49},"identifiers":[{"type":"semgrep_id","name":"java_inject_rule-SqlInjection","value":"java_inject_rule-SqlInjection"},{"type":"cwe","name":"CWE-89","value":"89","url":"https://cwe.mitre.org/data/definitions/89.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"}]},{"id":"4482e1ba00301ca2f6d7d1228570ef2e0f97bd1f72809e92e58a888c24f1db3a","category":"sast","name":"Improper neutralization of special elements used in an SQL command ('SQL Injection')","description":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user-supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `\u003e` or `\u003c` comparison\noperators. In these cases, do not use a user supplied `\u003e` or `\u003c` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `\u003e` and `\u003c`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nExample on using CriteriaBuilder to build queries\n```\npublic List\u003cYourEntity\u003e findBySomeCriteria(EntityManager entityManager, String criteriaValue) {\n    CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();\n    CriteriaQuery\u003cYourEntity\u003e query = criteriaBuilder.createQuery(YourEntity.class);\n    Root\u003cYourEntity\u003e root = query.from(YourEntity.class);\n\n    query.select(root).where(criteriaBuilder.equal(root.get(\"someProperty\"), criteriaValue));\n\n    return entityManager.createQuery(query).getResultList();\n}\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n","cve":"semgrep_id:java_inject_rule-SqlInjection:52:52","severity":"High","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","start_line":52},"identifiers":[{"type":"semgrep_id","name":"java_inject_rule-SqlInjection","value":"java_inject_rule-SqlInjection"},{"type":"cwe","name":"CWE-89","value":"89","url":"https://cwe.mitre.org/data/definitions/89.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"}]},{"id":"1c09efb5f317016997b527506835b862e7d78b7c778c9ee6ca874f2576e9a770","category":"sast","name":"Improper neutralization of special elements used in an SQL command ('SQL Injection')","description":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user-supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `\u003e` or `\u003c` comparison\noperators. In these cases, do not use a user supplied `\u003e` or `\u003c` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `\u003e` and `\u003c`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nExample on using CriteriaBuilder to build queries\n```\npublic List\u003cYourEntity\u003e findBySomeCriteria(EntityManager entityManager, String criteriaValue) {\n    CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();\n    CriteriaQuery\u003cYourEntity\u003e query = criteriaBuilder.createQuery(YourEntity.class);\n    Root\u003cYourEntity\u003e root = query.from(YourEntity.class);\n\n    query.select(root).where(criteriaBuilder.equal(root.get(\"someProperty\"), criteriaValue));\n\n    return entityManager.createQuery(query).getResultList();\n}\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n","cve":"semgrep_id:java_inject_rule-SqlInjection:56:56","severity":"High","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java","start_line":56},"identifiers":[{"type":"semgrep_id","name":"java_inject_rule-SqlInjection","value":"java_inject_rule-SqlInjection"},{"type":"cwe","name":"CWE-89","value":"89","url":"https://cwe.mitre.org/data/definitions/89.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"}]},{"id":"e86987ee6c9b8f8f078c0f299dd2c401dee2f511a885427e50cc37e5dae99d39","category":"sast","name":"Improper neutralization of special elements used in an SQL command ('SQL Injection')","description":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user-supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `\u003e` or `\u003c` comparison\noperators. In these cases, do not use a user supplied `\u003e` or `\u003c` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `\u003e` and `\u003c`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nExample on using CriteriaBuilder to build queries\n```\npublic List\u003cYourEntity\u003e findBySomeCriteria(EntityManager entityManager, String criteriaValue) {\n    CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();\n    CriteriaQuery\u003cYourEntity\u003e query = criteriaBuilder.createQuery(YourEntity.class);\n    Root\u003cYourEntity\u003e root = query.from(YourEntity.class);\n\n    query.select(root).where(criteriaBuilder.equal(root.get(\"someProperty\"), criteriaValue));\n\n    return entityManager.createQuery(query).getResultList();\n}\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n","cve":"semgrep_id:java_inject_rule-SqlInjection:57:57","severity":"High","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","start_line":57},"identifiers":[{"type":"semgrep_id","name":"java_inject_rule-SqlInjection","value":"java_inject_rule-SqlInjection"},{"type":"cwe","name":"CWE-89","value":"89","url":"https://cwe.mitre.org/data/definitions/89.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"}]},{"id":"542610abeafa1ee9660ca035ee4b05d9b96b52a29a13b87f79ed82fb955441b4","category":"sast","name":"Improper neutralization of special elements used in an SQL command ('SQL Injection')","description":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user-supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `\u003e` or `\u003c` comparison\noperators. In these cases, do not use a user supplied `\u003e` or `\u003c` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `\u003e` and `\u003c`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nExample on using CriteriaBuilder to build queries\n```\npublic List\u003cYourEntity\u003e findBySomeCriteria(EntityManager entityManager, String criteriaValue) {\n    CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();\n    CriteriaQuery\u003cYourEntity\u003e query = criteriaBuilder.createQuery(YourEntity.class);\n    Root\u003cYourEntity\u003e root = query.from(YourEntity.class);\n\n    query.select(root).where(criteriaBuilder.equal(root.get(\"someProperty\"), criteriaValue));\n\n    return entityManager.createQuery(query).getResultList();\n}\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n","cve":"semgrep_id:java_inject_rule-SqlInjection:62:62","severity":"High","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","start_line":62},"identifiers":[{"type":"semgrep_id","name":"java_inject_rule-SqlInjection","value":"java_inject_rule-SqlInjection"},{"type":"cwe","name":"CWE-89","value":"89","url":"https://cwe.mitre.org/data/definitions/89.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"}]},{"id":"94dae20a3b2ff611f8c084651d91b508db92a75e795a0f3004cf977ae23716aa","category":"sast","name":"Improper neutralization of special elements used in an SQL command ('SQL Injection')","description":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user-supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `\u003e` or `\u003c` comparison\noperators. In these cases, do not use a user supplied `\u003e` or `\u003c` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `\u003e` and `\u003c`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nExample on using CriteriaBuilder to build queries\n```\npublic List\u003cYourEntity\u003e findBySomeCriteria(EntityManager entityManager, String criteriaValue) {\n    CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();\n    CriteriaQuery\u003cYourEntity\u003e query = criteriaBuilder.createQuery(YourEntity.class);\n    Root\u003cYourEntity\u003e root = query.from(YourEntity.class);\n\n    query.select(root).where(criteriaBuilder.equal(root.get(\"someProperty\"), criteriaValue));\n\n    return entityManager.createQuery(query).getResultList();\n}\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n","cve":"semgrep_id:java_inject_rule-SqlInjection:65:65","severity":"High","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5.java","start_line":65},"identifiers":[{"type":"semgrep_id","name":"java_inject_rule-SqlInjection","value":"java_inject_rule-SqlInjection"},{"type":"cwe","name":"CWE-89","value":"89","url":"https://cwe.mitre.org/data/definitions/89.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"}]},{"id":"94e841915e922e82e651229886d64537b5fe4d860ac9424ff36b8d1ae78fc58e","category":"sast","name":"Improper neutralization of special elements used in an SQL command ('SQL Injection')","description":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user-supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `\u003e` or `\u003c` comparison\noperators. In these cases, do not use a user supplied `\u003e` or `\u003c` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `\u003e` and `\u003c`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nExample on using CriteriaBuilder to build queries\n```\npublic List\u003cYourEntity\u003e findBySomeCriteria(EntityManager entityManager, String criteriaValue) {\n    CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();\n    CriteriaQuery\u003cYourEntity\u003e query = criteriaBuilder.createQuery(YourEntity.class);\n    Root\u003cYourEntity\u003e root = query.from(YourEntity.class);\n\n    query.select(root).where(criteriaBuilder.equal(root.get(\"someProperty\"), criteriaValue));\n\n    return entityManager.createQuery(query).getResultList();\n}\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n","cve":"semgrep_id:java_inject_rule-SqlInjection:65:65","severity":"High","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","start_line":65},"identifiers":[{"type":"semgrep_id","name":"java_inject_rule-SqlInjection","value":"java_inject_rule-SqlInjection"},{"type":"cwe","name":"CWE-89","value":"89","url":"https://cwe.mitre.org/data/definitions/89.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"}]},{"id":"79f1787fc24fbac00325ceeb4d1e90bea3cefd43abd5a26bdf5d25cfc0c68950","category":"sast","name":"Improper neutralization of special elements used in an SQL command ('SQL Injection')","description":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user-supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `\u003e` or `\u003c` comparison\noperators. In these cases, do not use a user supplied `\u003e` or `\u003c` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `\u003e` and `\u003c`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nExample on using CriteriaBuilder to build queries\n```\npublic List\u003cYourEntity\u003e findBySomeCriteria(EntityManager entityManager, String criteriaValue) {\n    CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();\n    CriteriaQuery\u003cYourEntity\u003e query = criteriaBuilder.createQuery(YourEntity.class);\n    Root\u003cYourEntity\u003e root = query.from(YourEntity.class);\n\n    query.select(root).where(criteriaBuilder.equal(root.get(\"someProperty\"), criteriaValue));\n\n    return entityManager.createQuery(query).getResultList();\n}\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n","cve":"semgrep_id:java_inject_rule-SqlInjection:72:72","severity":"High","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java","start_line":72},"identifiers":[{"type":"semgrep_id","name":"java_inject_rule-SqlInjection","value":"java_inject_rule-SqlInjection"},{"type":"cwe","name":"CWE-89","value":"89","url":"https://cwe.mitre.org/data/definitions/89.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"}]},{"id":"253b0926bed7112f31131f7855648ff357eb6f518cd534699d99ed711087bd0c","category":"sast","name":"Improper neutralization of special elements used in an SQL command ('SQL Injection')","description":"SQL Injection is a critical vulnerability that can lead to data or system compromise. By\ndynamically generating SQL query strings, user input may be able to influence the logic of\nthe SQL statement. This could lead to an adversary accessing information they should\nnot have access to, or in some circumstances, being able to execute OS functionality or code.\n\nReplace all dynamically generated SQL queries with parameterized queries. In situations where\ndynamic queries must be created, never use direct user input, but instead use a map or\ndictionary of valid values and resolve them using a user-supplied key.\n\nFor example, some database drivers do not allow parameterized queries for `\u003e` or `\u003c` comparison\noperators. In these cases, do not use a user supplied `\u003e` or `\u003c` value, but rather have the\nuser\nsupply a `gt` or `lt` value. The alphabetical values are then used to look up the `\u003e` and `\u003c`\nvalues to be used in the construction of the dynamic query. The same goes for other queries\nwhere\ncolumn or table names are required but cannot be parameterized.\n\nExample using `PreparedStatement` queries:\n```\n// Some userInput\nString userInput = \"someUserInput\";\n// Your connection string\nString url = \"...\";\n// Get a connection from the DB via the DriverManager\nConnection conn = DriverManager.getConnection(url);\n// Create a prepared statement\nPreparedStatement st = conn.prepareStatement(\"SELECT name FROM table where name=?\");\n// Set each parameters value by the index (starting from 1)\nst.setString(1, userInput);\n// Execute query and get the result set\nResultSet rs = st.executeQuery();\n// Iterate over results\nwhile (rs.next()) {\n    // Get result for this row at the provided column number (starting from 1)\n    String result = rs.getString(1);\n    // ...\n}\n// Close the ResultSet\nrs.close();\n// Close the PreparedStatement\nst.close();\n```\n\nExample on using CriteriaBuilder to build queries\n```\npublic List\u003cYourEntity\u003e findBySomeCriteria(EntityManager entityManager, String criteriaValue) {\n    CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();\n    CriteriaQuery\u003cYourEntity\u003e query = criteriaBuilder.createQuery(YourEntity.class);\n    Root\u003cYourEntity\u003e root = query.from(YourEntity.class);\n\n    query.select(root).where(criteriaBuilder.equal(root.get(\"someProperty\"), criteriaValue));\n\n    return entityManager.createQuery(query).getResultList();\n}\n```\n\nFor more information on SQL Injection see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\n","cve":"semgrep_id:java_inject_rule-SqlInjection:94:94","severity":"High","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","start_line":94},"identifiers":[{"type":"semgrep_id","name":"java_inject_rule-SqlInjection","value":"java_inject_rule-SqlInjection"},{"type":"cwe","name":"CWE-89","value":"89","url":"https://cwe.mitre.org/data/definitions/89.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"}]},{"id":"e5cf4e9e2ad72cfb7e961511387ede584acb3e2f719f12a3779330e8cfe5a3b0","category":"sast","name":"Regular expression with non-literal value","description":"The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n","cve":"semgrep_id:eslint.detect-non-literal-regexp:1:1","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/resources/webgoat/static/js/libs/backbone-min.js","start_line":1},"identifiers":[{"type":"semgrep_id","name":"eslint.detect-non-literal-regexp","value":"eslint.detect-non-literal-regexp","url":"https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"},{"type":"cwe","name":"CWE-185","value":"185","url":"https://cwe.mitre.org/data/definitions/185.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"},{"type":"eslint_rule_id","name":"ESLint rule ID/detect-non-literal-regexp","value":"detect-non-literal-regexp"}]},{"id":"0f5d880dd7350c1ca08ec1f428c77eea4323ddb7b19b42b17890b9a1c5c30da7","category":"sast","name":"Regular expression with non-literal value","description":"The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n","cve":"semgrep_id:eslint.detect-non-literal-regexp:4079:4079","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/resources/webgoat/static/plugins/bootstrap-wysihtml5/js/wysihtml5-0.3.0.js","start_line":4079},"identifiers":[{"type":"semgrep_id","name":"eslint.detect-non-literal-regexp","value":"eslint.detect-non-literal-regexp","url":"https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"},{"type":"cwe","name":"CWE-185","value":"185","url":"https://cwe.mitre.org/data/definitions/185.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"},{"type":"eslint_rule_id","name":"ESLint rule ID/detect-non-literal-regexp","value":"detect-non-literal-regexp"}]},{"id":"b3dbca164e0f740a58fabee54363d990d2d302806e11b4d70cb28b15f9753755","category":"sast","name":"Regular expression with non-literal value","description":"The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n","cve":"semgrep_id:eslint.detect-non-literal-regexp:4088:4088","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/resources/webgoat/static/plugins/bootstrap-wysihtml5/js/wysihtml5-0.3.0.js","start_line":4088},"identifiers":[{"type":"semgrep_id","name":"eslint.detect-non-literal-regexp","value":"eslint.detect-non-literal-regexp","url":"https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"},{"type":"cwe","name":"CWE-185","value":"185","url":"https://cwe.mitre.org/data/definitions/185.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"},{"type":"eslint_rule_id","name":"ESLint rule ID/detect-non-literal-regexp","value":"detect-non-literal-regexp"}]},{"id":"8ed8c0768607c6dfaa8c5325e1868d9008c98cd7acc6ff06acfa9426fd439dd5","category":"sast","name":"Regular expression with non-literal value","description":"The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n","cve":"semgrep_id:eslint.detect-non-literal-regexp:573:575","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/resources/webgoat/static/js/libs/mode-java.js","start_line":573,"end_line":575},"identifiers":[{"type":"semgrep_id","name":"eslint.detect-non-literal-regexp","value":"eslint.detect-non-literal-regexp","url":"https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"},{"type":"cwe","name":"CWE-185","value":"185","url":"https://cwe.mitre.org/data/definitions/185.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"},{"type":"eslint_rule_id","name":"ESLint rule ID/detect-non-literal-regexp","value":"detect-non-literal-regexp"}]},{"id":"7aae279cc58e138ea461735ae54f2b43cac7452749d9614c61c490890194a8b7","category":"sast","name":"Regular expression with non-literal value","description":"The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n","cve":"semgrep_id:eslint.detect-non-literal-regexp:576:578","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/resources/webgoat/static/js/libs/mode-java.js","start_line":576,"end_line":578},"identifiers":[{"type":"semgrep_id","name":"eslint.detect-non-literal-regexp","value":"eslint.detect-non-literal-regexp","url":"https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"},{"type":"cwe","name":"CWE-185","value":"185","url":"https://cwe.mitre.org/data/definitions/185.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"},{"type":"eslint_rule_id","name":"ESLint rule ID/detect-non-literal-regexp","value":"detect-non-literal-regexp"}]},{"id":"98530e978f47b9aa43c825f25865fd7931327b52e944cf7f7903dff0fade8a04","category":"sast","name":"Regular expression with non-literal value","description":"The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n","cve":"semgrep_id:eslint.detect-non-literal-regexp:6:6","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/resources/webgoat/static/js/libs/underscore-min.js","start_line":6},"identifiers":[{"type":"semgrep_id","name":"eslint.detect-non-literal-regexp","value":"eslint.detect-non-literal-regexp","url":"https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"},{"type":"cwe","name":"CWE-185","value":"185","url":"https://cwe.mitre.org/data/definitions/185.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"},{"type":"eslint_rule_id","name":"ESLint rule ID/detect-non-literal-regexp","value":"detect-non-literal-regexp"}]},{"id":"98530e978f47b9aa43c825f25865fd7931327b52e944cf7f7903dff0fade8a04","category":"sast","name":"Regular expression with non-literal value","description":"The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n","cve":"semgrep_id:eslint.detect-non-literal-regexp:6:6","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/resources/webgoat/static/js/libs/underscore-min.js","start_line":6},"identifiers":[{"type":"semgrep_id","name":"eslint.detect-non-literal-regexp","value":"eslint.detect-non-literal-regexp","url":"https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"},{"type":"cwe","name":"CWE-185","value":"185","url":"https://cwe.mitre.org/data/definitions/185.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"},{"type":"eslint_rule_id","name":"ESLint rule ID/detect-non-literal-regexp","value":"detect-non-literal-regexp"}]},{"id":"98530e978f47b9aa43c825f25865fd7931327b52e944cf7f7903dff0fade8a04","category":"sast","name":"Regular expression with non-literal value","description":"The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n","cve":"semgrep_id:eslint.detect-non-literal-regexp:6:6","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/resources/webgoat/static/js/libs/underscore-min.js","start_line":6},"identifiers":[{"type":"semgrep_id","name":"eslint.detect-non-literal-regexp","value":"eslint.detect-non-literal-regexp","url":"https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"},{"type":"cwe","name":"CWE-185","value":"185","url":"https://cwe.mitre.org/data/definitions/185.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"},{"type":"eslint_rule_id","name":"ESLint rule ID/detect-non-literal-regexp","value":"detect-non-literal-regexp"}]},{"id":"80160911c7e6ab89158a480b4014cff294fa57a5324574bb14660f5ea0a1b287","category":"sast","name":"Regular expression with non-literal value","description":"The `RegExp` constructor was called with a non-literal value. If an adversary were able to\nsupply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)\nagainst the application. In Node applications, this could cause the entire application to no\nlonger be responsive to other users' requests.\n\nTo remediate this issue, never allow user-supplied regular expressions. Instead, the regular \nexpression should be  hardcoded. If this is not possible, consider using an alternative regular\nexpression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative \nthat does not support backtracking, which is what leads to ReDoS.\n\nExample using re2 which does not support backtracking (Note: it is still recommended to\nnever use user-supplied input):\n```\n// Import the re2 module\nconst RE2 = require('re2');\n\nfunction match(userSuppliedRegex, userInput) {\n    // Create a RE2 object with the user supplied regex, this is relatively safe\n    // due to RE2 not supporting backtracking which can be abused to cause long running\n    // queries\n    var re = new RE2(userSuppliedRegex);\n    // Execute the regular expression against some userInput\n    var result = re.exec(userInput);\n    // Work with the result\n}\n```\n\nFor more information on Regular Expression DoS see:\n- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\n","cve":"semgrep_id:eslint.detect-non-literal-regexp:843:843","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/resources/webgoat/static/plugins/bootstrap-wysihtml5/js/wysihtml5-0.3.0.js","start_line":843},"identifiers":[{"type":"semgrep_id","name":"eslint.detect-non-literal-regexp","value":"eslint.detect-non-literal-regexp","url":"https://semgrep.dev/r/gitlab.eslint.detect-non-literal-regexp"},{"type":"cwe","name":"CWE-185","value":"185","url":"https://cwe.mitre.org/data/definitions/185.html"},{"type":"owasp","name":"A03:2021 - Injection","value":"A03:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"},{"type":"eslint_rule_id","name":"ESLint rule ID/detect-non-literal-regexp","value":"detect-non-literal-regexp"}]},{"id":"3d225f486f77854edba50c3e8a0b9eae7d3caa8d3564e606ef221781be91ce3c","category":"sast","name":"Server-Side Request Forgery (SSRF)","description":"Server-Side-Request-Forgery (SSRF) exploits backend systems that initiate requests to third\nparties.\nIf user input is used in constructing or sending these requests, an attacker could supply\nmalicious\ndata to force the request to other systems or modify request data to cause unwanted actions.\n\nEnsure user input is not used directly in constructing URLs or URIs when initiating requests\nto third party\nsystems from back end systems. Care must also be taken when constructing payloads using user\ninput. Where\npossible restrict to known URIs or payloads. Consider using a server-side map where keys are\nused to return\nURLs such as `https://site/goto?key=1` where `{key: 1, url: 'http://some.url/', key: 2, url:\n'http://...'}`.\n\nIf you must use user-supplied input for requesting URLs, it is strongly recommended that the\nHTTP client\nchosen allows you to customize and block certain IP ranges at the network level. By blocking\nRFC 1918\naddresses or other network address ranges, you can limit the severity of a successful SSRF\nattack. Care must\nalso be taken to block certain protocol or address formatting such as IPv6.\n\nIf you cannot block address ranges at the client level, you may want to run the HTTP client\nas a protected\nuser, or in a protected network where you can apply IP Table or firewall rules to block access\nto dangerous\naddresses. Finally, if none of the above protections are available, you could also run a\ncustom HTTP proxy\nand force all requests through it to handle blocking dangerous addresses.\n\nExample using a map to look up a key to be used in a HTTP request:\n```\nHashMap\u003cString, String\u003e lookupTable = new HashMap\u003c\u003e();\nlookupTable.put(\"key1\", \"https://example.com/\");\nlookupTable.put(\"key2\", \"https://safeurl.com/\");\nString userInput = request.getParameter(\"key\");\n\n// Create a CloseableHttpClient, ideally any requests issued should be done\n// out-of-band from the servlet request itself (such as using a separate thread/scheduler\nsystem)\ntry (final CloseableHttpClient httpClient = HttpClients.createDefault()) {\n    // Lookup the value from our user input from our lookupTable\n    String value = lookupTable.getOrDefault(userInput, \"https://example.com/\");\n    // Construct the url, with the hardcoded url and only pass in the value from the\nlookupTable,\n    // not direct user input\n    final HttpGet httpget = new HttpGet(value);\n    // Execute the request\n    CloseableHttpResponse clientResponse = httpClient.execute(httpget);\n    // Read the response\n    byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();\n    // Handle the response\n    // ...\n}\n```\n\nIf using a map is not possible, the user-supplied input must be encoded prior to use, and\nnever allow full\nURLs:\n```\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Encode the string using java.net.URLEncoder with the UTF-8 character set\nString encodedString = java.net.URLEncoder.encode(userInput, StandardCharsets.UTF_8);\n// Create a CloseableHttpClient, ideally any requests issued should be done\n// out-of-band from the servlet request itself (such as using a separate thread/scheduler\nsystem)\ntry (final CloseableHttpClient httpClient = HttpClients.createDefault()) {\n  // Construct the url, with the hardcoded url and only pass in the encoded value, never a\nfull URL\n  final HttpGet httpget = new HttpGet(\"https://example.com/getId?key=\"+encodedString);\n  // Execute the request\n  CloseableHttpResponse clientResponse = httpClient.execute(httpget);\n  // Read the response\n  byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();\n  // handle the response\n}\n```\n\nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n","cve":"semgrep_id:find_sec_bugs.URLCONNECTION_SSRF_FD-1:36:36","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","start_line":36},"identifiers":[{"type":"semgrep_id","name":"find_sec_bugs.URLCONNECTION_SSRF_FD-1","value":"find_sec_bugs.URLCONNECTION_SSRF_FD-1"},{"type":"cwe","name":"CWE-918","value":"918","url":"https://cwe.mitre.org/data/definitions/918.html"},{"type":"owasp","name":"A10:2021 - Server-Side Request Forgery","value":"A10:2021"},{"type":"owasp","name":"A1:2017 - Injection","value":"A1:2017"},{"type":"find_sec_bugs_type","name":"Find Security Bugs-URLCONNECTION_SSRF_FD","value":"URLCONNECTION_SSRF_FD"}]},{"id":"aaa637ab0ccfcabf86da7017ae3c449316d936ed09e59a70d085549dc568f2e7","category":"sast","name":"Use of a broken or risky cryptographic algorithm (SHA1/MD5)","description":"The application was found using an insecure or risky digest or signature algorithm. Both MD5\nand SHA1 hash algorithms have been found to be vulnerable to producing collisions.\nThis means\nthat two different values, when hashed, can lead to the same hash value. If the application is\ntrying\nto use these hash methods for storing passwords, then it is recommended to switch to a\npassword hashing\nalgorithm such as Argon2id or PBKDF2.\nstrongly recommended that a standard Digest algorithm be chosen instead as implementing\na digest by hand is error-prone.\n\nExample of creating a SHA-384 hash:\n```\n// Create a MessageDigest using the SHA-384 algorithm\nMessageDigest sha384Digest = MessageDigest.getInstance(\"SHA-384\");\n// Call update with your data\nsha384Digest.update(input);\n// Only call digest once all data has been fed into the update sha384digest instance\nbyte[] output = sha384Digest.digest();\n// output base64 encoded version of the hash\nSystem.out.println(\"hash: \" + Base64.getEncoder().encodeToString(output));\n```\n\nFor more information on secure password storage see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html\n","cve":"semgrep_id:find_sec_bugs.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1:39:39","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java","start_line":39},"identifiers":[{"type":"semgrep_id","name":"find_sec_bugs.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1","value":"find_sec_bugs.WEAK_MESSAGE_DIGEST_MD5-1.WEAK_MESSAGE_DIGEST_SHA1-1"},{"type":"cwe","name":"CWE-327","value":"327","url":"https://cwe.mitre.org/data/definitions/327.html"},{"type":"owasp","name":"A04:2021 - Insecure Design","value":"A04:2021"},{"type":"owasp","name":"A6:2017 - Security Misconfiguration","value":"A6:2017"},{"type":"find_sec_bugs_type","name":"Find Security Bugs-WEAK_MESSAGE_DIGEST_MD5","value":"WEAK_MESSAGE_DIGEST_MD5"},{"type":"find_sec_bugs_type","name":"Find Security Bugs-WEAK_MESSAGE_DIGEST_SHA1","value":"WEAK_MESSAGE_DIGEST_SHA1"}]},{"id":"fc8dc12974e6347f5f682691fb200e3d878915d6ddb4cc6bbcb3ffbbdd0a6824","category":"sast","name":"Cross-site request forgery (CSRF)","description":"Detected a method annotated with 'RequestMapping' that does not specify\nthe HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE, or\nOPTIONS, and by default all HTTP methods are allowed when the HTTP method\nis not explicitly specified. This means that a method that performs state\nchanges could be vulnerable to CSRF attacks. Cross-Site Request Forgery (CSRF) \nis a security vulnerability where an attacker tricks a user into performing \nunintended actions on a web application where they are authenticated. This \ncan lead to unauthorized actions like changing user settings, transferring \nfunds, or altering passwords, all without the user's knowledge, by exploiting \nthe trust a web application has in the user's browser.\n\nTo mitigate, add the 'method' field and specify the HTTP method (such as \n'RequestMethod.POST').\n\nSecure Code Example:\n```\n@RequestMapping(value = \"/path\", method = RequestMethod.POST)\npublic void safe() {\n    // State-changing operations performed within this method.\n}\n```\n","cve":"semgrep_id:java_csrf_rule-UnrestrictedRequestMapping:22:22","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/container/service/SessionService.java","start_line":22},"identifiers":[{"type":"semgrep_id","name":"java_csrf_rule-UnrestrictedRequestMapping","value":"java_csrf_rule-UnrestrictedRequestMapping","url":"https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING"},{"type":"cwe","name":"CWE-352","value":"352","url":"https://cwe.mitre.org/data/definitions/352.html"},{"type":"owasp","name":"A01:2021 - Broken Access Control","value":"A01:2021"},{"type":"owasp","name":"A5:2017 - Broken Access Control","value":"A5:2017"}]},{"id":"313b895678fd7ba5a6d674eb4e7e7aa37afc96842ccd2f7882fb7bc2b4c530e9","category":"sast","name":"Cross-site request forgery (CSRF)","description":"Detected a method annotated with 'RequestMapping' that does not specify\nthe HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE, or\nOPTIONS, and by default all HTTP methods are allowed when the HTTP method\nis not explicitly specified. This means that a method that performs state\nchanges could be vulnerable to CSRF attacks. Cross-Site Request Forgery (CSRF) \nis a security vulnerability where an attacker tricks a user into performing \nunintended actions on a web application where they are authenticated. This \ncan lead to unauthorized actions like changing user settings, transferring \nfunds, or altering passwords, all without the user's knowledge, by exploiting \nthe trust a web application has in the user's browser.\n\nTo mitigate, add the 'method' field and specify the HTTP method (such as \n'RequestMethod.POST').\n\nSecure Code Example:\n```\n@RequestMapping(value = \"/path\", method = RequestMethod.POST)\npublic void safe() {\n    // State-changing operations performed within this method.\n}\n```\n","cve":"semgrep_id:java_csrf_rule-UnrestrictedRequestMapping:30:30","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java","start_line":30},"identifiers":[{"type":"semgrep_id","name":"java_csrf_rule-UnrestrictedRequestMapping","value":"java_csrf_rule-UnrestrictedRequestMapping","url":"https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING"},{"type":"cwe","name":"CWE-352","value":"352","url":"https://cwe.mitre.org/data/definitions/352.html"},{"type":"owasp","name":"A01:2021 - Broken Access Control","value":"A01:2021"},{"type":"owasp","name":"A5:2017 - Broken Access Control","value":"A5:2017"}]},{"id":"23d92ac98101f798a936117136d8c419e3ea0b1b243194cbfc13521082d9c78a","category":"sast","name":"Cross-site request forgery (CSRF)","description":"Detected a method annotated with 'RequestMapping' that does not specify\nthe HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE, or\nOPTIONS, and by default all HTTP methods are allowed when the HTTP method\nis not explicitly specified. This means that a method that performs state\nchanges could be vulnerable to CSRF attacks. Cross-Site Request Forgery (CSRF) \nis a security vulnerability where an attacker tricks a user into performing \nunintended actions on a web application where they are authenticated. This \ncan lead to unauthorized actions like changing user settings, transferring \nfunds, or altering passwords, all without the user's knowledge, by exploiting \nthe trust a web application has in the user's browser.\n\nTo mitigate, add the 'method' field and specify the HTTP method (such as \n'RequestMethod.POST').\n\nSecure Code Example:\n```\n@RequestMapping(value = \"/path\", method = RequestMethod.POST)\npublic void safe() {\n    // State-changing operations performed within this method.\n}\n```\n","cve":"semgrep_id:java_csrf_rule-UnrestrictedRequestMapping:35:35","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/container/service/LabelDebugService.java","start_line":35},"identifiers":[{"type":"semgrep_id","name":"java_csrf_rule-UnrestrictedRequestMapping","value":"java_csrf_rule-UnrestrictedRequestMapping","url":"https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING"},{"type":"cwe","name":"CWE-352","value":"352","url":"https://cwe.mitre.org/data/definitions/352.html"},{"type":"owasp","name":"A01:2021 - Broken Access Control","value":"A01:2021"},{"type":"owasp","name":"A5:2017 - Broken Access Control","value":"A5:2017"}]},{"id":"6c555f9961c3ab43398d1e6397df9fb412f4bc8da3d162ef4ff0544114d7eddc","category":"sast","name":"Cross-site request forgery (CSRF)","description":"Detected a method annotated with 'RequestMapping' that does not specify\nthe HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE, or\nOPTIONS, and by default all HTTP methods are allowed when the HTTP method\nis not explicitly specified. This means that a method that performs state\nchanges could be vulnerable to CSRF attacks. Cross-Site Request Forgery (CSRF) \nis a security vulnerability where an attacker tricks a user into performing \nunintended actions on a web application where they are authenticated. This \ncan lead to unauthorized actions like changing user settings, transferring \nfunds, or altering passwords, all without the user's knowledge, by exploiting \nthe trust a web application has in the user's browser.\n\nTo mitigate, add the 'method' field and specify the HTTP method (such as \n'RequestMethod.POST').\n\nSecure Code Example:\n```\n@RequestMapping(value = \"/path\", method = RequestMethod.POST)\npublic void safe() {\n    // State-changing operations performed within this method.\n}\n```\n","cve":"semgrep_id:java_csrf_rule-UnrestrictedRequestMapping:37:37","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/cryptography/SigningAssignment.java","start_line":37},"identifiers":[{"type":"semgrep_id","name":"java_csrf_rule-UnrestrictedRequestMapping","value":"java_csrf_rule-UnrestrictedRequestMapping","url":"https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING"},{"type":"cwe","name":"CWE-352","value":"352","url":"https://cwe.mitre.org/data/definitions/352.html"},{"type":"owasp","name":"A01:2021 - Broken Access Control","value":"A01:2021"},{"type":"owasp","name":"A5:2017 - Broken Access Control","value":"A5:2017"}]},{"id":"71ffe083138af5ba2e68c322a4f0322b95707053dd53e56d932fedcedc11ad29","category":"sast","name":"Cross-site request forgery (CSRF)","description":"Detected a method annotated with 'RequestMapping' that does not specify\nthe HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE, or\nOPTIONS, and by default all HTTP methods are allowed when the HTTP method\nis not explicitly specified. This means that a method that performs state\nchanges could be vulnerable to CSRF attacks. Cross-Site Request Forgery (CSRF) \nis a security vulnerability where an attacker tricks a user into performing \nunintended actions on a web application where they are authenticated. This \ncan lead to unauthorized actions like changing user settings, transferring \nfunds, or altering passwords, all without the user's knowledge, by exploiting \nthe trust a web application has in the user's browser.\n\nTo mitigate, add the 'method' field and specify the HTTP method (such as \n'RequestMethod.POST').\n\nSecure Code Example:\n```\n@RequestMapping(value = \"/path\", method = RequestMethod.POST)\npublic void safe() {\n    // State-changing operations performed within this method.\n}\n```\n","cve":"semgrep_id:java_csrf_rule-UnrestrictedRequestMapping:43:43","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTSecretKeyEndpoint.java","start_line":43},"identifiers":[{"type":"semgrep_id","name":"java_csrf_rule-UnrestrictedRequestMapping","value":"java_csrf_rule-UnrestrictedRequestMapping","url":"https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING"},{"type":"cwe","name":"CWE-352","value":"352","url":"https://cwe.mitre.org/data/definitions/352.html"},{"type":"owasp","name":"A01:2021 - Broken Access Control","value":"A01:2021"},{"type":"owasp","name":"A5:2017 - Broken Access Control","value":"A5:2017"}]},{"id":"c4ccd5960a86d6dccd2b5e6d7358a2cffd1ea4393eadfcda351da6db7905f49e","category":"sast","name":"Cross-site request forgery (CSRF)","description":"Detected a method annotated with 'RequestMapping' that does not specify\nthe HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE, or\nOPTIONS, and by default all HTTP methods are allowed when the HTTP method\nis not explicitly specified. This means that a method that performs state\nchanges could be vulnerable to CSRF attacks. Cross-Site Request Forgery (CSRF) \nis a security vulnerability where an attacker tricks a user into performing \nunintended actions on a web application where they are authenticated. This \ncan lead to unauthorized actions like changing user settings, transferring \nfunds, or altering passwords, all without the user's knowledge, by exploiting \nthe trust a web application has in the user's browser.\n\nTo mitigate, add the 'method' field and specify the HTTP method (such as \n'RequestMethod.POST').\n\nSecure Code Example:\n```\n@RequestMapping(value = \"/path\", method = RequestMethod.POST)\npublic void safe() {\n    // State-changing operations performed within this method.\n}\n```\n","cve":"semgrep_id:java_csrf_rule-UnrestrictedRequestMapping:44:44","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/container/service/LessonMenuService.java","start_line":44},"identifiers":[{"type":"semgrep_id","name":"java_csrf_rule-UnrestrictedRequestMapping","value":"java_csrf_rule-UnrestrictedRequestMapping","url":"https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING"},{"type":"cwe","name":"CWE-352","value":"352","url":"https://cwe.mitre.org/data/definitions/352.html"},{"type":"owasp","name":"A01:2021 - Broken Access Control","value":"A01:2021"},{"type":"owasp","name":"A5:2017 - Broken Access Control","value":"A5:2017"}]},{"id":"d1b421991125d73847e63a2fed538d6cb6b68a9bedd849d7fc6bdb003f18eba5","category":"sast","name":"Cross-site request forgery (CSRF)","description":"Detected a method annotated with 'RequestMapping' that does not specify\nthe HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE, or\nOPTIONS, and by default all HTTP methods are allowed when the HTTP method\nis not explicitly specified. This means that a method that performs state\nchanges could be vulnerable to CSRF attacks. Cross-Site Request Forgery (CSRF) \nis a security vulnerability where an attacker tricks a user into performing \nunintended actions on a web application where they are authenticated. This \ncan lead to unauthorized actions like changing user settings, transferring \nfunds, or altering passwords, all without the user's knowledge, by exploiting \nthe trust a web application has in the user's browser.\n\nTo mitigate, add the 'method' field and specify the HTTP method (such as \n'RequestMethod.POST').\n\nSecure Code Example:\n```\n@RequestMapping(value = \"/path\", method = RequestMethod.POST)\npublic void safe() {\n    // State-changing operations performed within this method.\n}\n```\n","cve":"semgrep_id:java_csrf_rule-UnrestrictedRequestMapping:48:48","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/container/service/LabelDebugService.java","start_line":48},"identifiers":[{"type":"semgrep_id","name":"java_csrf_rule-UnrestrictedRequestMapping","value":"java_csrf_rule-UnrestrictedRequestMapping","url":"https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING"},{"type":"cwe","name":"CWE-352","value":"352","url":"https://cwe.mitre.org/data/definitions/352.html"},{"type":"owasp","name":"A01:2021 - Broken Access Control","value":"A01:2021"},{"type":"owasp","name":"A5:2017 - Broken Access Control","value":"A5:2017"}]},{"id":"c4be06d1b5944d656842c93d8febca7093a3a7ffafd6e0d1d2a73da96e7eb534","category":"sast","name":"Cross-site request forgery (CSRF)","description":"Detected a method annotated with 'RequestMapping' that does not specify\nthe HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE, or\nOPTIONS, and by default all HTTP methods are allowed when the HTTP method\nis not explicitly specified. This means that a method that performs state\nchanges could be vulnerable to CSRF attacks. Cross-Site Request Forgery (CSRF) \nis a security vulnerability where an attacker tricks a user into performing \nunintended actions on a web application where they are authenticated. This \ncan lead to unauthorized actions like changing user settings, transferring \nfunds, or altering passwords, all without the user's knowledge, by exploiting \nthe trust a web application has in the user's browser.\n\nTo mitigate, add the 'method' field and specify the HTTP method (such as \n'RequestMethod.POST').\n\nSecure Code Example:\n```\n@RequestMapping(value = \"/path\", method = RequestMethod.POST)\npublic void safe() {\n    // State-changing operations performed within this method.\n}\n```\n","cve":"semgrep_id:java_csrf_rule-UnrestrictedRequestMapping:49:49","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java","start_line":49},"identifiers":[{"type":"semgrep_id","name":"java_csrf_rule-UnrestrictedRequestMapping","value":"java_csrf_rule-UnrestrictedRequestMapping","url":"https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING"},{"type":"cwe","name":"CWE-352","value":"352","url":"https://cwe.mitre.org/data/definitions/352.html"},{"type":"owasp","name":"A01:2021 - Broken Access Control","value":"A01:2021"},{"type":"owasp","name":"A5:2017 - Broken Access Control","value":"A5:2017"}]},{"id":"b4346120543838d59e177528198e2ff43a778c32123c3816c902bf6d96f14b06","category":"sast","name":"Cross-site request forgery (CSRF)","description":"Detected a method annotated with 'RequestMapping' that does not specify\nthe HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE, or\nOPTIONS, and by default all HTTP methods are allowed when the HTTP method\nis not explicitly specified. This means that a method that performs state\nchanges could be vulnerable to CSRF attacks. Cross-Site Request Forgery (CSRF) \nis a security vulnerability where an attacker tricks a user into performing \nunintended actions on a web application where they are authenticated. This \ncan lead to unauthorized actions like changing user settings, transferring \nfunds, or altering passwords, all without the user's knowledge, by exploiting \nthe trust a web application has in the user's browser.\n\nTo mitigate, add the 'method' field and specify the HTTP method (such as \n'RequestMethod.POST').\n\nSecure Code Example:\n```\n@RequestMapping(value = \"/path\", method = RequestMethod.POST)\npublic void safe() {\n    // State-changing operations performed within this method.\n}\n```\n","cve":"semgrep_id:java_csrf_rule-UnrestrictedRequestMapping:56:56","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","start_line":56},"identifiers":[{"type":"semgrep_id","name":"java_csrf_rule-UnrestrictedRequestMapping","value":"java_csrf_rule-UnrestrictedRequestMapping","url":"https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING"},{"type":"cwe","name":"CWE-352","value":"352","url":"https://cwe.mitre.org/data/definitions/352.html"},{"type":"owasp","name":"A01:2021 - Broken Access Control","value":"A01:2021"},{"type":"owasp","name":"A5:2017 - Broken Access Control","value":"A5:2017"}]},{"id":"f73166bbeedd376ae5d004f2c63772d8257fa5c19176d655b01baae0aa098066","category":"sast","name":"Cross-site request forgery (CSRF)","description":"Detected a method annotated with 'RequestMapping' that does not specify\nthe HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE, or\nOPTIONS, and by default all HTTP methods are allowed when the HTTP method\nis not explicitly specified. This means that a method that performs state\nchanges could be vulnerable to CSRF attacks. Cross-Site Request Forgery (CSRF) \nis a security vulnerability where an attacker tricks a user into performing \nunintended actions on a web application where they are authenticated. This \ncan lead to unauthorized actions like changing user settings, transferring \nfunds, or altering passwords, all without the user's knowledge, by exploiting \nthe trust a web application has in the user's browser.\n\nTo mitigate, add the 'method' field and specify the HTTP method (such as \n'RequestMethod.POST').\n\nSecure Code Example:\n```\n@RequestMapping(value = \"/path\", method = RequestMethod.POST)\npublic void safe() {\n    // State-changing operations performed within this method.\n}\n```\n","cve":"semgrep_id:java_csrf_rule-UnrestrictedRequestMapping:77:77","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/xxe/SimpleXXE.java","start_line":77},"identifiers":[{"type":"semgrep_id","name":"java_csrf_rule-UnrestrictedRequestMapping","value":"java_csrf_rule-UnrestrictedRequestMapping","url":"https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING"},{"type":"cwe","name":"CWE-352","value":"352","url":"https://cwe.mitre.org/data/definitions/352.html"},{"type":"owasp","name":"A01:2021 - Broken Access Control","value":"A01:2021"},{"type":"owasp","name":"A5:2017 - Broken Access Control","value":"A5:2017"}]},{"id":"d225072394c93a8c11efcce9541d4cfbb5f522c138533a1828cd1064f9c1f545","category":"sast","name":"Use of cryptographically weak pseudo-random number generator (PRNG)","description":"This rule identifies use of cryptographically weak random number generators.\nUsing cryptographically weak random number generators like `crypto.pseudoRandomBytes()` \nand `Math.random()` for security-critical tasks can expose systems to significant \nvulnerabilities. Attackers might predict the generated random numbers, compromising \nthe integrity and confidentiality of cryptographic operations. This could lead to \nbreaches where sensitive data is accessed or manipulated, authentication mechanisms \nare bypassed, or secure communications are intercepted, ultimately undermining the \nsecurity of the entire system or application.\n\nMitigation strategy:\nReplace the use of these cryptographically weak random number generators with \n`crypto.randomBytes()`, a method provided by Node.js's `crypto` module that \ngenerates cryptographically secure random numbers. This method should be used \nfor all operations requiring secure randomness, such as generating keys, tokens, \nor any cryptographic material.\n\nSecure Code Example:\n```\nconst crypto = require('crypto');\nconst secureBytes = crypto.randomBytes(256);\nconsole.log(`Secure random bytes: ${secureBytes.toString('hex')}`);\n```\n","cve":"semgrep_id:nodejs_scan.javascript-crypto-rule-node_insecure_random_generator:6:6","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/resources/webgoat/static/js/libs/underscore-min.js","start_line":6},"identifiers":[{"type":"semgrep_id","name":"nodejs_scan.javascript-crypto-rule-node_insecure_random_generator","value":"nodejs_scan.javascript-crypto-rule-node_insecure_random_generator"},{"type":"cwe","name":"CWE-338","value":"338","url":"https://cwe.mitre.org/data/definitions/338.html"},{"type":"owasp","name":"A02:2021 - Cryptographic Failures","value":"A02:2021"},{"type":"owasp","name":"A3:2017 - Sensitive Data Exposure","value":"A3:2017"},{"type":"njsscan_rule_type","name":"NodeJS Scan ID javascript-crypto-rule-node_insecure_random_generator","value":"crypto.pseudoRandomBytes()/Math.random() is a cryptographically weak random number generator."}]},{"id":"f0d67ff299e1dfe88057df9c975d69f3284eb083577a136397676cd0915689d5","category":"sast","name":"Incorrect regular expression","description":"Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service.\n","cve":"semgrep_id:nodejs_scan.javascript-dos-rule-regex_dos:534:534","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/resources/webgoat/static/js/libs/mode-java.js","start_line":534},"identifiers":[{"type":"semgrep_id","name":"nodejs_scan.javascript-dos-rule-regex_dos","value":"nodejs_scan.javascript-dos-rule-regex_dos"},{"type":"cwe","name":"CWE-185","value":"185","url":"https://cwe.mitre.org/data/definitions/185.html"},{"type":"owasp","name":"A05:2021 - Security Misconfiguration","value":"A05:2021"},{"type":"owasp","name":"A6:2017 - Security Misconfiguration","value":"A6:2017"},{"type":"njsscan_rule_type","name":"NodeJS Scan ID javascript-dos-rule-regex_dos","value":"Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service."}]},{"id":"a3b211ad9f84fda43019f39412c90b32bfb4addc0f5cb7079eb2d3d2a92c5cda","category":"sast","name":"Incorrect regular expression","description":"Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service.\n","cve":"semgrep_id:nodejs_scan.javascript-dos-rule-regex_dos:685:686","severity":"Medium","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/resources/webgoat/static/js/libs/mode-java.js","start_line":685,"end_line":686},"identifiers":[{"type":"semgrep_id","name":"nodejs_scan.javascript-dos-rule-regex_dos","value":"nodejs_scan.javascript-dos-rule-regex_dos"},{"type":"cwe","name":"CWE-185","value":"185","url":"https://cwe.mitre.org/data/definitions/185.html"},{"type":"owasp","name":"A05:2021 - Security Misconfiguration","value":"A05:2021"},{"type":"owasp","name":"A6:2017 - Security Misconfiguration","value":"A6:2017"},{"type":"njsscan_rule_type","name":"NodeJS Scan ID javascript-dos-rule-regex_dos","value":"Ensure that the regex used to compare with user supplied input is safe from regular expression denial of service."}]},{"id":"2caa7f3dd0e8f0d81053e259dfde99d2a4334cf259522fdfde4ba3c1747f0db9","category":"sast","name":"Sensitive cookie in HTTPS session without 'Secure' attribute","description":"The `Secure` attribute when set to `true` protects the cookie value from being being\ntransmitted over clear text\ncommunication paths such as HTTP. By enabling this protection, the cookie will only be sent\nover HTTPS.\n\nExample of protecting a `Cookie`:\n```\n// Create an Secure cookie.\nCookie someCookie = new Cookie(\"SomeCookieName\", \"SomeValue\");\n// Set Secure flag to true\nsomeCookie.setSecure(true);\n```\n\nFor more information see:\nhttps://jakarta.ee/specifications/servlet/4.0/apidocs/javax/servlet/http/cookie#setSecure-boolean-\n\nSession cookies should be configured with the following security directives:\n\n- [HTTPOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)\n- [Secure](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n","cve":"semgrep_id:find_sec_bugs.INSECURE_COOKIE-1:114:115","severity":"Low","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java","start_line":114,"end_line":115},"identifiers":[{"type":"semgrep_id","name":"find_sec_bugs.INSECURE_COOKIE-1","value":"find_sec_bugs.INSECURE_COOKIE-1"},{"type":"cwe","name":"CWE-614","value":"614","url":"https://cwe.mitre.org/data/definitions/614.html"},{"type":"owasp","name":"A05:2021 - Security Misconfiguration","value":"A05:2021"},{"type":"owasp","name":"A6:2017 - Security Misconfiguration","value":"A6:2017"},{"type":"find_sec_bugs_type","name":"Find Security Bugs-INSECURE_COOKIE","value":"INSECURE_COOKIE"}]},{"id":"3b98117d34f253e84f8676624a23ab4f7e4e81a21f15c059204c37a1197c9674","category":"sast","name":"Sensitive cookie in HTTPS session without 'Secure' attribute","description":"The `Secure` attribute when set to `true` protects the cookie value from being being\ntransmitted over clear text\ncommunication paths such as HTTP. By enabling this protection, the cookie will only be sent\nover HTTPS.\n\nExample of protecting a `Cookie`:\n```\n// Create an Secure cookie.\nCookie someCookie = new Cookie(\"SomeCookieName\", \"SomeValue\");\n// Set Secure flag to true\nsomeCookie.setSecure(true);\n```\n\nFor more information see:\nhttps://jakarta.ee/specifications/servlet/4.0/apidocs/javax/servlet/http/cookie#setSecure-boolean-\n\nSession cookies should be configured with the following security directives:\n\n- [HTTPOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)\n- [Secure](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n","cve":"semgrep_id:find_sec_bugs.INSECURE_COOKIE-1:119:120","severity":"Low","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java","start_line":119,"end_line":120},"identifiers":[{"type":"semgrep_id","name":"find_sec_bugs.INSECURE_COOKIE-1","value":"find_sec_bugs.INSECURE_COOKIE-1"},{"type":"cwe","name":"CWE-614","value":"614","url":"https://cwe.mitre.org/data/definitions/614.html"},{"type":"owasp","name":"A05:2021 - Security Misconfiguration","value":"A05:2021"},{"type":"owasp","name":"A6:2017 - Security Misconfiguration","value":"A6:2017"},{"type":"find_sec_bugs_type","name":"Find Security Bugs-INSECURE_COOKIE","value":"INSECURE_COOKIE"}]},{"id":"44a2254a868ecdba8a6e755e50767883d0f9a15980569af1013d958b04fd8fcb","category":"sast","name":"Sensitive cookie in HTTPS session without 'Secure' attribute","description":"The `Secure` attribute when set to `true` protects the cookie value from being being\ntransmitted over clear text\ncommunication paths such as HTTP. By enabling this protection, the cookie will only be sent\nover HTTPS.\n\nExample of protecting a `Cookie`:\n```\n// Create an Secure cookie.\nCookie someCookie = new Cookie(\"SomeCookieName\", \"SomeValue\");\n// Set Secure flag to true\nsomeCookie.setSecure(true);\n```\n\nFor more information see:\nhttps://jakarta.ee/specifications/servlet/4.0/apidocs/javax/servlet/http/cookie#setSecure-boolean-\n\nSession cookies should be configured with the following security directives:\n\n- [HTTPOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)\n- [Secure](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n","cve":"semgrep_id:find_sec_bugs.INSECURE_COOKIE-1:58:60","severity":"Low","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignment.java","start_line":58,"end_line":60},"identifiers":[{"type":"semgrep_id","name":"find_sec_bugs.INSECURE_COOKIE-1","value":"find_sec_bugs.INSECURE_COOKIE-1"},{"type":"cwe","name":"CWE-614","value":"614","url":"https://cwe.mitre.org/data/definitions/614.html"},{"type":"owasp","name":"A05:2021 - Security Misconfiguration","value":"A05:2021"},{"type":"owasp","name":"A6:2017 - Security Misconfiguration","value":"A6:2017"},{"type":"find_sec_bugs_type","name":"Find Security Bugs-INSECURE_COOKIE","value":"INSECURE_COOKIE"}]},{"id":"ca54f72d4d9639722c5b11a930f307be3a2d50985bf0dc74c0699cdee49c42b3","category":"sast","name":"Sensitive cookie without 'HttpOnly' flag","description":"The `HttpOnly` attribute when set to `true` protects the cookie value from being accessed by\nclient side JavaScript such\nas reading the `document.cookie` values. By enabling this protection, a website that is\nvulnerable to\nCross-Site Scripting (XSS) will be able to block malicious scripts from accessing the cookie\nvalue from JavaScript.\n\nExample of protecting a `Cookie`:\n```\n// Create an HttpOnly cookie.\nCookie someCookie = new Cookie(\"SomeCookieName\", \"SomeValue\");\n// Set HttpOnly flag to true\nsomeCookie.setHttpOnly(true);\n```\n\nFor more information see:\nhttps://jakarta.ee/specifications/servlet/4.0/apidocs/javax/servlet/http/cookie#setHttpOnly-boolean-\n\nSession cookies should be configured with the following security directives:\n\n- [HTTPOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [Secure](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)\n","cve":"semgrep_id:java_cookie_rule-CookieHTTPOnly:115:115","severity":"Low","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java","start_line":115},"identifiers":[{"type":"semgrep_id","name":"java_cookie_rule-CookieHTTPOnly","value":"java_cookie_rule-CookieHTTPOnly"},{"type":"cwe","name":"CWE-1004","value":"1004","url":"https://cwe.mitre.org/data/definitions/1004.html"},{"type":"owasp","name":"A05:2021 - Security Misconfiguration","value":"A05:2021"},{"type":"owasp","name":"A6:2017 - Security Misconfiguration","value":"A6:2017"}]},{"id":"813ee30887d77fe88106d0db3329f140f28c7f5eb67fdd36e4e6ab5da7c153ba","category":"sast","name":"Sensitive cookie without 'HttpOnly' flag","description":"The `HttpOnly` attribute when set to `true` protects the cookie value from being accessed by\nclient side JavaScript such\nas reading the `document.cookie` values. By enabling this protection, a website that is\nvulnerable to\nCross-Site Scripting (XSS) will be able to block malicious scripts from accessing the cookie\nvalue from JavaScript.\n\nExample of protecting a `Cookie`:\n```\n// Create an HttpOnly cookie.\nCookie someCookie = new Cookie(\"SomeCookieName\", \"SomeValue\");\n// Set HttpOnly flag to true\nsomeCookie.setHttpOnly(true);\n```\n\nFor more information see:\nhttps://jakarta.ee/specifications/servlet/4.0/apidocs/javax/servlet/http/cookie#setHttpOnly-boolean-\n\nSession cookies should be configured with the following security directives:\n\n- [HTTPOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [Secure](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)\n","cve":"semgrep_id:java_cookie_rule-CookieHTTPOnly:120:120","severity":"Low","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java","start_line":120},"identifiers":[{"type":"semgrep_id","name":"java_cookie_rule-CookieHTTPOnly","value":"java_cookie_rule-CookieHTTPOnly"},{"type":"cwe","name":"CWE-1004","value":"1004","url":"https://cwe.mitre.org/data/definitions/1004.html"},{"type":"owasp","name":"A05:2021 - Security Misconfiguration","value":"A05:2021"},{"type":"owasp","name":"A6:2017 - Security Misconfiguration","value":"A6:2017"}]},{"id":"d1972ae0e5e1e27d00ddcaa36130ea4d974afeac3f4db423fcbbf9db002ccc96","category":"sast","name":"Sensitive cookie without 'HttpOnly' flag","description":"The `HttpOnly` attribute when set to `true` protects the cookie value from being accessed by\nclient side JavaScript such\nas reading the `document.cookie` values. By enabling this protection, a website that is\nvulnerable to\nCross-Site Scripting (XSS) will be able to block malicious scripts from accessing the cookie\nvalue from JavaScript.\n\nExample of protecting a `Cookie`:\n```\n// Create an HttpOnly cookie.\nCookie someCookie = new Cookie(\"SomeCookieName\", \"SomeValue\");\n// Set HttpOnly flag to true\nsomeCookie.setHttpOnly(true);\n```\n\nFor more information see:\nhttps://jakarta.ee/specifications/servlet/4.0/apidocs/javax/servlet/http/cookie#setHttpOnly-boolean-\n\nSession cookies should be configured with the following security directives:\n\n- [HTTPOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [Secure](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)\n","cve":"semgrep_id:java_cookie_rule-CookieHTTPOnly:60:60","severity":"Low","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignment.java","start_line":60},"identifiers":[{"type":"semgrep_id","name":"java_cookie_rule-CookieHTTPOnly","value":"java_cookie_rule-CookieHTTPOnly"},{"type":"cwe","name":"CWE-1004","value":"1004","url":"https://cwe.mitre.org/data/definitions/1004.html"},{"type":"owasp","name":"A05:2021 - Security Misconfiguration","value":"A05:2021"},{"type":"owasp","name":"A6:2017 - Security Misconfiguration","value":"A6:2017"}]},{"id":"334b151143d62bc139870074022d54604d0b4722f9188919f5523528bfc1feae","category":"sast","name":"Sensitive cookie without 'HttpOnly' flag","description":"The `HttpOnly` attribute when set to `true` protects the cookie value from being accessed by\nclient side JavaScript such\nas reading the `document.cookie` values. By enabling this protection, a website that is\nvulnerable to\nCross-Site Scripting (XSS) will be able to block malicious scripts from accessing the cookie\nvalue from JavaScript.\n\nExample of protecting a `Cookie`:\n```\n// Create an HttpOnly cookie.\nCookie someCookie = new Cookie(\"SomeCookieName\", \"SomeValue\");\n// Set HttpOnly flag to true\nsomeCookie.setHttpOnly(true);\n```\n\nFor more information see:\nhttps://jakarta.ee/specifications/servlet/4.0/apidocs/javax/servlet/http/cookie#setHttpOnly-boolean-\n\nSession cookies should be configured with the following security directives:\n\n- [HTTPOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [Secure](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)\n","cve":"semgrep_id:java_cookie_rule-CookieHTTPOnly:70:70","severity":"Low","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/hijacksession/HijackSessionAssignment.java","start_line":70},"identifiers":[{"type":"semgrep_id","name":"java_cookie_rule-CookieHTTPOnly","value":"java_cookie_rule-CookieHTTPOnly"},{"type":"cwe","name":"CWE-1004","value":"1004","url":"https://cwe.mitre.org/data/definitions/1004.html"},{"type":"owasp","name":"A05:2021 - Security Misconfiguration","value":"A05:2021"},{"type":"owasp","name":"A6:2017 - Security Misconfiguration","value":"A6:2017"}]},{"id":"f6e8e0bc270aa8f20a98d790e16489c49344a384715b4222ed10ba4614a1d850","category":"sast","name":"Sensitive cookie without 'HttpOnly' flag","description":"The `HttpOnly` attribute when set to `true` protects the cookie value from being accessed by\nclient side JavaScript such\nas reading the `document.cookie` values. By enabling this protection, a website that is\nvulnerable to\nCross-Site Scripting (XSS) will be able to block malicious scripts from accessing the cookie\nvalue from JavaScript.\n\nExample of protecting a `Cookie`:\n```\n// Create an HttpOnly cookie.\nCookie someCookie = new Cookie(\"SomeCookieName\", \"SomeValue\");\n// Set HttpOnly flag to true\nsomeCookie.setHttpOnly(true);\n```\n\nFor more information see:\nhttps://jakarta.ee/specifications/servlet/4.0/apidocs/javax/servlet/http/cookie#setHttpOnly-boolean-\n\nSession cookies should be configured with the following security directives:\n\n- [HTTPOnly](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [Secure](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n- [SameSite](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)\n","cve":"semgrep_id:java_cookie_rule-CookieHTTPOnly:77:77","severity":"Low","scanner":{"id":"semgrep","name":"Semgrep"},"location":{"file":"src/main/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignment.java","start_line":77},"identifiers":[{"type":"semgrep_id","name":"java_cookie_rule-CookieHTTPOnly","value":"java_cookie_rule-CookieHTTPOnly"},{"type":"cwe","name":"CWE-1004","value":"1004","url":"https://cwe.mitre.org/data/definitions/1004.html"},{"type":"owasp","name":"A05:2021 - Security Misconfiguration","value":"A05:2021"},{"type":"owasp","name":"A6:2017 - Security Misconfiguration","value":"A6:2017"}]}],"scan":{"analyzer":{"id":"semgrep","name":"Semgrep","url":"https://gitlab.com/gitlab-org/security-products/analyzers/semgrep","vendor":{"name":"GitLab"},"version":"6.6.0"},"scanner":{"id":"semgrep","name":"Semgrep","url":"https://github.com/returntocorp/semgrep","vendor":{"name":"GitLab"},"version":"1.118.0"},"type":"sast","start_time":"2025-08-18T17:06:05","end_time":"2025-08-18T17:07:12","status":"success","observability":{"events":[{"event":"collect_sast_scan_metrics_from_pipeline","property":"e0e81145-af46-4ccb-9ad0-ad0265946330","label":"semgrep","value":0,"version":"6.6.0","exit_code":2,"override_count":0,"passthrough_count":0,"custom_exclude_path_count":0,"time_s":66,"file_count":513}]}}}
